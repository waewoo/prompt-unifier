---
name: Terraform State Management
description: Best practices for configuring, securing, and managing Terraform state
  files.
globs:
- '**/*.tf'
alwaysApply: false
category: infrastructure
version: 1.0.0
tags:
- terraform
- state
- backend
- security
- remote
author: prompt-unifier
language: hcl
---
# Terraform State Management

This document outlines the critical best practices for managing Terraform state, which is a snapshot of your infrastructure. Proper state management is crucial for operational stability and security.

## 1. Remote State Backend

- **Principle**: Always use a remote backend for storing Terraform state. Never store state locally.
- **Reason**:
  - **Collaboration**: Enables multiple team members to work on the same infrastructure without state conflicts.
  - **Durability**: Protects against data loss if a local machine fails.
  - **Security**: Remote backends often offer encryption at rest and access controls.
- **Recommended Backends**:
  - **AWS S3**: Highly durable, scalable, and integrates well with AWS IAM.
  - **Azure Storage Account**: Similar benefits for Azure environments.
  - **Google Cloud Storage**: For GCP environments.
  - **Terraform Cloud/Enterprise**: Offers advanced features like remote operations, state versioning, and policy enforcement.

```terraform
# Example: AWS S3 Backend
terraform {
  backend "s3" {
    bucket         = "my-terraform-state-bucket" # Must be created manually
    key            = "environments/prod/my-app/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "my-terraform-state-lock" # For state locking
  }
}
```

## 2. State Locking

- **Principle**: Configure state locking for your remote backend.
- **Reason**: Prevents concurrent Terraform runs from corrupting the state file. When an operation starts, the state is locked, and other operations must wait until the lock is released.
- **Implementation**: Most remote backends (S3, Azure Storage, GCS) support state locking. For S3, AWS DynamoDB is commonly used.

```terraform
# Example: DynamoDB table for S3 state locking
resource "aws_dynamodb_table" "terraform_state_lock" {
  name         = "my-terraform-state-lock"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }

  tags = {
    Name        = "TerraformStateLock"
    Environment = "shared"
  }
}
```

## 3. Securing Terraform State

Terraform state files contain sensitive information about your infrastructure, including potentially sensitive data (even if marked `sensitive=true` in variables/outputs, it's still in the state).

- **Encryption at Rest**: Ensure your remote backend encrypts the state file at rest.
  - **AWS S3**: Use S3 bucket encryption (SSE-S3 or KMS).
  - **Azure Storage**: Encryption is enabled by default.
  - **GCS**: Encryption is enabled by default.
- **Access Control**: Implement strict IAM policies to limit who can read or write to the state backend. Only CI/CD pipelines and authorized engineers should have access.
- **State Versioning**: Enable versioning on your state backend (e.g., S3 bucket versioning) to keep a history of state changes and allow rollbacks.
- **Never Commit State**: The `terraform.tfstate` file must **NEVER** be committed to version control. Add `*.tfstate` and `*.tfstate.backup` to your `.gitignore`.

## 4. Managing Sensitive Data in State

- **Principle**: Avoid storing sensitive data directly in Terraform state whenever possible.
- **Alternative**: Use dedicated secrets management tools (e.g., HashiCorp Vault, AWS Secrets Manager) to store and retrieve secrets at runtime. Terraform can then fetch these secrets dynamically.
- **If unavoidable**: If a sensitive value must be in state (e.g., a database password generated by Terraform), ensure the state file itself is highly secured as per point 3.

```terraform
# Good: Fetching a secret from AWS Secrets Manager
data "aws_secretsmanager_secret_version" "db_password" {
  secret_id = "my-app/db-password"
}

resource "aws_rds_cluster_instance" "my_db" {
  # ...
  password = data.aws_secretsmanager_secret_version.db_password.secret_string
}
```