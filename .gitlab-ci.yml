# GitLab CI/CD Pipeline for Prompt Manager CLI
# This pipeline runs security checks and quality checks on every push
# Ensures security and code quality standards are maintained across the team

# Use Python 3.12 Docker image for all jobs (unless specified otherwise)
image: python:3.12

# Global variables
variables:
  SECURE_LOG_LEVEL: "info"

# Define pipeline stages (executed in order)
stages:
  - security
  - lint
  - typecheck
  - test
  - release

# Cache Poetry dependencies to speed up pipeline execution
cache:
  paths:
    - .cache/pypoetry
    - .venv

# Install Poetry and project dependencies before each job
before_script:
  - pip install poetry
  - poetry config virtualenvs.in-project true
  - poetry install --no-interaction --no-ansi

# ============================================================================
# SECURITY JOBS
# ============================================================================

# Security Job 1: Secrets Detection
secrets-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    - apt-get update && apt-get install -y git
    - pip install detect-secrets
  script:
    - detect-secrets scan --baseline .secrets.baseline
  allow_failure: false
  only:
    - merge_requests
    - main
  cache:
    paths:
      - .pip-cache

# Security Job 2: SAST (Static Application Security Testing)
sast-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    - pip install poetry
    - poetry config virtualenvs.create false
    - poetry install --no-root --only main,dev
  script:
    - poetry run bandit -r src/ -f json -o bandit-report.json
    - poetry run bandit -r src/ -f screen
  artifacts:
    reports:
      sast: bandit-report.json
    paths:
      - bandit-report.json
    expire_in: 1 week
    when: always
  allow_failure: false
  only:
    - merge_requests
    - main

# Security Job 3: Dependency Vulnerability Scanning
dependency-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    - pip install poetry safety pip-audit
    - poetry config virtualenvs.create false
    - poetry install --no-root
  script:
    - echo "Running Safety scan..."
    - poetry run safety scan --output text || true
    - echo "Running pip-audit scan..."
    - poetry run pip-audit --format json --output pip-audit-report.json || true
    - poetry run pip-audit
  artifacts:
    paths:
      - pip-audit-report.json
    expire_in: 1 week
    when: always
  allow_failure: false
  only:
    - merge_requests
    - main

# ============================================================================
# CODE QUALITY JOBS
# ============================================================================

# Job 1: Run Ruff linter
lint:
  stage: lint
  script:
    - poetry run ruff check src/ tests/
  only:
    - branches
    - merge_requests

# Job 2: Run mypy type checker
typecheck:
  stage: typecheck
  script:
    - poetry run mypy src/
  only:
    - branches
    - merge_requests

# Job 3: Run pytest test suite with coverage
test:
  stage: test
  script:
    - poetry run pytest --cov=src/prompt_manager --cov-report=term-missing --cov-report=xml --cov-report=html
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - htmlcov/
      - coverage.xml
    expire_in: 30 days
  only:
    - branches
    - merge_requests

# ============================================================================
# RELEASE JOB
# ============================================================================

create-release:
  stage: release
  image: python:3.12
  before_script:
    - pip install poetry commitizen
    - poetry config virtualenvs.in-project true
    - poetry install --no-interaction --no-ansi
    - apt-get update && apt-get install -y git-core
  script:
    - echo "Building distribution packages..."
    - poetry build
    - echo "Generating changelog..."
    - poetry run cz changelog --incremental > CHANGELOG.md
    
    # Stocker le contenu du changelog de manière sûre
    - |
      CHANGELOG_CONTENT=$(cat CHANGELOG.md)
      RELEASE_TAG=${CI_COMMIT_TAG}
      RELEASE_NAME="Release ${RELEASE_TAG}"
    
    # Créer le JSON des assets de manière sûre
    - |
      ASSET_LINK_SDIST='{"name":"sdist","url":"'"${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/dist/*.tar.gz"'"}'
      ASSET_LINK_WHEEL='{"name":"wheel","url":"'"${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/dist/*.whl"'"}'
    
    # Exécuter release-cli avec les paramètres correctement échappés
    - |
      release-cli create \
        --name "${RELEASE_NAME}" \
        --tag "${RELEASE_TAG}" \
        --description "${CHANGELOG_CONTENT}" \
        --assets-link "${ASSET_LINK_SDIST}" \
        --assets-link "${ASSET_LINK_WHEEL}"
  
  artifacts:
    paths:
      - dist/
      - CHANGELOG.md
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/ && $CI_COMMIT_BRANCH == "main"'
      when: on_success
      allow_failure: false