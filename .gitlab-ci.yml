# GitLab CI/CD Pipeline for Prompt Manager CLI
#
# Optimized pipeline with:
# - Quality checks first for fast feedback
# - Security scans after quality
# - Skip quality/security on tags (already tested on main)
# - Release notes automatically generated by Commitizen
# - Manual release for control over publication timing

variables:
  SECURE_LOG_LEVEL: "info"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  POETRY_HOME: "$CI_PROJECT_DIR/.poetry"
  POETRY_VIRTUALENVS_IN_PROJECT: "true"
  POETRY_NO_INTERACTION: "1"

# Default image for all jobs
image: python:3.12

# Pipeline stages (executed in order)
stages:
  - quality    # Fast checks (lint, typecheck, test) in parallel
  - security   # Security scans
  - release    # Manual version bump + automatic release creation

# Cache Poetry to speed up execution
cache:
  key:
    files:
      - poetry.lock
  paths:
    - .venv/
    - .cache/pip
    - .poetry/

# Install Poetry and dependencies before each job
before_script:
  - pip install --quiet poetry
  - poetry install --no-interaction --no-ansi

# ============================================================================
# QUALITY JOBS - Fast feedback on code quality
# ============================================================================

lint:
  stage: quality
  script:
    - poetry run ruff check src/ tests/
  rules:
    # Skip on tags (already tested on branch before bump)
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH'

typecheck:
  stage: quality
  script:
    - poetry run mypy src/
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH'

test:
  stage: quality
  script:
    - poetry run pytest --cov=src/prompt_manager --cov-report=term-missing --cov-report=xml --cov-report=html
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - htmlcov/
      - coverage.xml
    expire_in: 30 days
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH'

# ============================================================================
# SECURITY JOBS
# ============================================================================

secrets-scan:
  stage: security
  image: python:3.11-slim
  cache:
    key: secrets-scan
    paths:
      - .cache/pip
  before_script:
    - apt-get update && apt-get install -y git
    - pip install --quiet detect-secrets
  script:
    - detect-secrets scan --baseline .secrets.baseline
  allow_failure: false
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

sast-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    - pip install --quiet poetry
    - poetry install --no-root --only main,dev
  script:
    - poetry run bandit -r src/ -f json -o bandit-report.json
    - poetry run bandit -r src/ -f screen
  artifacts:
    reports:
      sast: bandit-report.json
    paths:
      - bandit-report.json
    expire_in: 1 week
    when: always
  allow_failure: false
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

dependency-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    - pip install --quiet poetry safety pip-audit
    - poetry install --no-root
  script:
    - echo "Running Safety scan..."
    - poetry run safety scan --output text || true
    - echo "Running pip-audit scan..."
    - poetry run pip-audit --format json --output pip-audit-report.json || true
    - poetry run pip-audit
  artifacts:
    paths:
      - pip-audit-report.json
    expire_in: 1 week
    when: always
  allow_failure: false
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

# ============================================================================
# RELEASE JOBS
# ============================================================================

# Job 1: Version Bump (MANUAL)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# This job appears in every main pipeline but requires manual trigger.
# Click "Play" when you're ready to create a release.
#
# Actions:
# 1. Analyzes commits since last version (Conventional Commits)
# 2. Calculates new version (patch/minor/major) automatically
# 3. Updates pyproject.toml and __init__.py
# 4. Generates/updates CHANGELOG.md
# 5. Creates a commit + Git tag
# 6. Pushes to GitLab
# 7. Automatically triggers create-release via the tag

auto-bump:
  stage: release
  image: python:3.12
  before_script:
    - pip install --quiet poetry commitizen
    - poetry install --no-interaction --no-ansi
    - apt-get update && apt-get install -y git-core
    
    # Configure Git to allow commits
    - git config user.email "${GITLAB_USER_EMAIL}"
    - git config user.name "${GITLAB_USER_NAME}"
    
    # Configure authentication to push changes
    - git remote set-url origin "https://oauth2:${CI_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - git checkout -B "${CI_COMMIT_REF_NAME}"
    
    # Version bump with Commitizen
    - |
      echo "ðŸš€ Running commitizen bump..."
      echo "This will:"
      echo "  - Analyze commits since last version"
      echo "  - Calculate new version (major/minor/patch)"
      echo "  - Update pyproject.toml and __init__.py"
      echo "  - Generate/update CHANGELOG.md"
      echo "  - Create a commit and tag"
      echo ""
      poetry run cz bump --changelog --yes || echo "âš ï¸  No version bump needed (no conventional commits found)"
    
    # Explicit push of branch AND tags
    - |
      echo ""
      echo "ðŸ“¤ Pushing changes and tags to GitLab..."
      git push origin "${CI_COMMIT_REF_NAME}"
      git push origin --tags
      echo "âœ… Done! The new tag will trigger the create-release job."
  rules:
    # Manual on main only, except for bump commits
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /^bump:/'
      when: manual
      allow_failure: false
  needs: ["test"]

# Job 2: GitLab Release Creation (AUTOMATIC on tag)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# This job is automatically triggered when a v*.*.* tag is pushed.
# It creates a GitLab Release with packages and release notes.

create-release:
  stage: release
  image: registry.gitlab.com/gitlab-org/cli:latest
  before_script:
    - apk add --no-cache python3 py3-pip git
    - pip install --break-system-packages poetry commitizen
    - poetry install --no-interaction --no-ansi
  script:
    - echo "ðŸ“¦ Building distribution packages for release ${CI_COMMIT_TAG}..."
    - poetry build

    # GÃ©nÃ©rer les release notes directement avec Commitizen sur la version du tag
    - |
      VERSION="${CI_COMMIT_TAG#v}"
      poetry run cz changelog --dry-run --unreleased-version="$VERSION" > RELEASE_NOTES.md || {
        echo "## Release ${CI_COMMIT_TAG}" > RELEASE_NOTES.md
        echo "" >> RELEASE_NOTES.md
        echo "See [CHANGELOG.md](./CHANGELOG.md) for full details." >> RELEASE_NOTES.md
      }

    - echo ""
    - echo "ðŸ“„ Release notes:"
    - echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    - cat RELEASE_NOTES.md
    - echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    - echo ""
    - echo "âœ… Packages built successfully:"
    - ls -lh dist/
  release:
    tag_name: '$CI_COMMIT_TAG'
    name: 'Release $CI_COMMIT_TAG'
    description: './RELEASE_NOTES.md'
    assets:
      links:
        - name: 'Python Wheel (.whl)'
          url: '${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/dist/prompt_manager-${CI_COMMIT_TAG#v}-py3-none-any.whl'
          link_type: 'package'
        - name: 'Source Distribution (.tar.gz)'
          url: '${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/dist/prompt_manager-${CI_COMMIT_TAG#v}.tar.gz'
          link_type: 'package'
  artifacts:
    paths:
      - dist/
      - RELEASE_NOTES.md
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: on_success
  needs: []

publish-pypi:
  stage: release
  before_script:
    - pip install --upgrade poetry
    - poetry install --no-interaction --no-ansi
  script:
    - poetry build
    - poetry publish --username $PYPI_USER --password $PYPI_PASSWORD --no-interaction
  rules:
    # Publie uniquement lors des releases taguÃ©es (vX.Y.Z) sur la branche main
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: on_success
  needs: []
  artifacts:
    paths:
      - dist/
    expire_in: 1 week
